package com.j256.simplewebframework.freemarker;

import java.io.File;
import java.io.IOException;
import java.io.Writer;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.eclipse.jetty.server.Request;

import com.j256.simplewebframework.displayer.FileResultDisplayer.FileInfo;
import com.j256.simplewebframework.displayer.ResultDisplayer;
import com.j256.simplewebframework.logger.Logger;
import com.j256.simplewebframework.logger.LoggerFactory;
import com.j256.simplewebframework.resource.FileLocator;
import com.j256.simplewebframework.util.ResponseUtils;

import freemarker.template.Configuration;
import freemarker.template.Template;
import freemarker.template.TemplateException;

/**
 * Any HTML files in the system will be rendered using this wrapper which sends the files back as a FreeMarker template.
 * 
 * @author graywatson
 */
public class FreemarkerHtmlDisplayer implements ResultDisplayer {

	private static final Logger logger = LoggerFactory.getLogger(FreemarkerHtmlDisplayer.class);
	@SuppressWarnings("unused")
	private static final Map<String, Object> readOnlyMap = new ReadOnlyMap();

	private Configuration templateConfig;
	private FileLocator fileLocator;

	@Override
	public Class<?>[] getHandledClasses() {
		return new Class[] { ModelView.class, FileInfo.class };
	}

	@Override
	public String[] getHandledMimeTypes() {
		return null;
	}

	@Override
	public boolean canRender(Class<?> resultClass, String mimeType) {
		return false;
	}

	@Override
	public boolean renderResult(Request request, HttpServletRequest servletRequest, HttpServletResponse response,
			Object result) throws IOException {
		ModelView modelView;
		FileInfo fileInfo;
		if (result instanceof ModelView) {
			modelView = (ModelView) result;
			String view = modelView.getView();
			if (view.startsWith("redirect:")) {
				String dest = view.substring(9);
				if (dest.startsWith("http:") || dest.startsWith("https:")) {
					ResponseUtils.sendRedirect(response, dest);
				} else {
					ResponseUtils.sendRelativeRedirect(servletRequest, response, dest);
				}
				return true;
			}
			fileInfo = fileLocator.findFile(view);
			if (fileInfo == null) {
				logger.error("template not found in path '{}'", view);
				return false;
			}
		} else if (result instanceof FileInfo) {
			fileInfo = (FileInfo) result;
			modelView = new ModelView(new HashMap<String, Object>(), fileInfo.getPath());
		} else {
			throw new IllegalArgumentException(
					"Cannot render the result of type: " + result.getClass().getSimpleName());
		}
		render(fileInfo, modelView.getModel(), request, servletRequest, response, response.getWriter());
		return true;
	}

	private boolean render(FileInfo fileInfo, Map<String, Object> model, Request request,
			HttpServletRequest servletRequest, HttpServletResponse servletResponse, Writer writer) throws IOException {

		servletResponse.setContentType("text/html");

		String path = fileInfo.getPath();
		File localFile = fileInfo.getFile();
		if (model == null) {
			model = new HashMap<String, Object>();
		}

		model.put("request", request);
		model.put("servletRequest", servletRequest);

		Template template;
		try {
			template = templateConfig.getTemplate(path);
		} catch (IOException e) {
			String msg = "problems getting template from path '" + path + "'";
			logger.error(e, msg);
			throw new IOException(msg, e);
		}

		try {
			template.process(model, writer);
			return true;
		} catch (TemplateException e) {
			String msg = "could not render template in " + localFile;
			logger.error(e, msg);
			throw new IOException(msg, e);
		} finally {
			// don't close it here
			writer.flush();
		}
	}

	public void setTemplateConfig(Configuration templateConfig) {
		this.templateConfig = templateConfig;
	}

	public void setFileLocator(FileLocator fileLocator) {
		this.fileLocator = fileLocator;
	}

	/**
	 * Little map that ignores any updates.
	 */
	private static class ReadOnlyMap implements Map<String, Object> {
		@Override
		public int size() {
			return 0;
		}
		@Override
		public boolean isEmpty() {
			return true;
		}
		@Override
		public boolean containsKey(Object key) {
			return false;
		}
		@Override
		public boolean containsValue(Object value) {
			return false;
		}
		@Override
		public Object get(Object key) {
			return null;
		}
		@Override
		public Object put(String key, Object value) {
			return null;
		}
		@Override
		public Object remove(Object key) {
			return null;
		}
		@Override
		public void putAll(Map<? extends String, ? extends Object> m) {
			// no-op
		}
		@Override
		public void clear() {
			// no-op
		}
		@Override
		public Set<String> keySet() {
			return Collections.emptySet();
		}
		@Override
		public Collection<Object> values() {
			return Collections.emptySet();
		}
		@Override
		public Set<java.util.Map.Entry<String, Object>> entrySet() {
			return Collections.emptySet();
		}
	}
}
